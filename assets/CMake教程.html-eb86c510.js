import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as a,c as i,d}from"./app-94a291f6.js";const n={},t=d(`<h1 id="cmake教程" tabindex="-1"><a class="header-anchor" href="#cmake教程" aria-hidden="true">#</a> CMake教程</h1><p>CMake是一个跨平台的管理源代码构建的工具。最初CMake被设计为的Makefile的生成器，现在CMake也可以生成现代的构建系统，如Ninja以及Visual Studio和Xcode等IDE的项目文件。CMake被广泛用于C和C++语言，也可以用于构建其他语言的源代码。</p><h2 id="cmakelists-txt-文件的编写" tabindex="-1"><a class="header-anchor" href="#cmakelists-txt-文件的编写" aria-hidden="true">#</a> CMakeLists.txt 文件的编写</h2><p>CMakeLists.txt 是 CMake 的配置文件，用于定义项目的源代码、依赖项和构建选项。在编写 CMakeLists.txt 文件时，通常需要包括以下几个部分：</p><h3 id="cmake-最低版本要求" tabindex="-1"><a class="header-anchor" href="#cmake-最低版本要求" aria-hidden="true">#</a> CMake 最低版本要求</h3><p>在 CMakeLists.txt 文件的开头，需要指定 CMake 的最低版本要求。这可以通过 cmake_minimum_required 命令来实现，例如：</p><p>cmake_minimum_required(VERSION 3.10)</p><h3 id="项目名称和源代码" tabindex="-1"><a class="header-anchor" href="#项目名称和源代码" aria-hidden="true">#</a> 项目名称和源代码</h3><p>接下来，需要指定项目的名称和源代码。这可以通过 project 和 add_executable 命令来实现，例如：</p><p>project(MyProject)</p><p>add_executable(my_exe main.cpp)</p><p>在这个例子中，我们指定了项目名称为 MyProject，将 main.cpp 文件添加到源代码中，并将生成的可执行文件命名为 my_exe。</p><h3 id="依赖项" tabindex="-1"><a class="header-anchor" href="#依赖项" aria-hidden="true">#</a> 依赖项</h3><p>如果项目依赖于其他库或框架，需要在 CMakeLists.txt 文件中指定这些依赖项。这可以通过 find_package 命令和 target_link_libraries 命令来实现。例如，如果项目依赖于 Boost 库，可以使用以下命令：</p><p>find_package(Boost REQUIRED)</p><p>target_link_libraries(my_exe Boost::boost)</p><h3 id="构建选项" tabindex="-1"><a class="header-anchor" href="#构建选项" aria-hidden="true">#</a> 构建选项</h3><p>最后，需要指定构建选项，例如编译器选项、链接器选项、目标平台等。这可以通过 add_compile_options 命令和 set 命令来实现。</p><p>例如，如果要使用 C++11 标准编译源代码，可以使用以下命令：</p><p>add_compile_options(-std=c++11)</p><p>在编译时启用警告信息可以帮助发现代码中的潜在问题，例如：</p><p>add_compile_options(-Wall)</p><p>这样可以启用所有警告信息，也可以根据需要启用特定的警告选项。</p><h2 id="项目配置和构建" tabindex="-1"><a class="header-anchor" href="#项目配置和构建" aria-hidden="true">#</a> 项目配置和构建</h2><p>在编写完 CMakeLists.txt 文件后，就可以进行项目配置和构建了。</p><p>下面是基本的项目配置和构建步骤：</p><h3 id="创建构建目录" tabindex="-1"><a class="header-anchor" href="#创建构建目录" aria-hidden="true">#</a> 创建构建目录</h3><p>首先，需要创建一个新的目录，用于构建项目。建议将该目录与源代码目录分开，并将其命名为 build，例如：</p><p>mkdir build</p><p>cd build</p><h3 id="配置项目" tabindex="-1"><a class="header-anchor" href="#配置项目" aria-hidden="true">#</a> 配置项目</h3><p>接下来，需要在构建目录中运行 CMake，以配置项目。可以使用以下命令：</p><p>cmake /path/to/source</p><p>其中，/path/to/source 是源代码目录的路径，一般就是上一层目录 .. 。</p><p>在配置项目时，可以指定一些选项，例如构建类型、目标平台等。这些选项可以通过 -D 参数传递给 CMake，例如：</p><p>cmake -DCMAKE_BUILD_TYPE=Release /path/to/source<br> 这个命令将指定构建类型为 Release。</p><h3 id="构建项目" tabindex="-1"><a class="header-anchor" href="#构建项目" aria-hidden="true">#</a> 构建项目</h3><p>配置完成后，就可以构建项目了。</p><p>可以使用以下命令：</p><p>cmake --build .</p><p>这个命令将使用默认的构建工具来构建项目。如果要使用特定的构建工具，可以使用 -G 参数，例如：</p><p>cmake -G &quot;Unix Makefiles&quot; --build .</p><p>这个命令将使用 Make 构建工具来构建项目，此时也可以直接运行 make 。</p><h3 id="运行项目" tabindex="-1"><a class="header-anchor" href="#运行项目" aria-hidden="true">#</a> 运行项目</h3><p>构建完成后，就可以运行生成的可执行文件了。如果使用默认的名称和路径，可以使用以下命令：</p><p>./my_exe</p><p>如果生成的可执行文件位于其他目录中，需要指定其完整路径，例如：</p><p>/path/to/build/my_exe</p><h2 id="交叉编译" tabindex="-1"><a class="header-anchor" href="#交叉编译" aria-hidden="true">#</a> 交叉编译</h2><p>CMake 支持交叉编译，可以在本地主机上构建针对嵌入式设备的代码。以下是几种不同的配置交叉编译的方法：</p><h3 id="设置交叉编译工具链" tabindex="-1"><a class="header-anchor" href="#设置交叉编译工具链" aria-hidden="true">#</a> 设置交叉编译工具链</h3><p>在 CMakeLists.txt 文件中，使用 set 命令设置交叉编译工具链，例如：</p><div class="language-txt line-numbers-mode" data-ext="txt"><pre class="language-txt"><code>set(CMAKE_SYSTEM_NAME Linux)
set(CMAKE_SYSTEM_PROCESSOR arm)
set(CMAKE_C_COMPILER /path/to/arm-linux-gcc)
set(CMAKE_CXX_COMPILER /path/to/arm-linux-g++)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里将系统名称设置为 Linux，处理器设置为 arm，C 编译器和 C++ 编译器设置为 arm-linux-gcc 和 arm-linux-g++，这些设置应根据实际情况进行修改。</p><p>可以将以上设置的内容保存到 arm-linux.cmake 文件中，然后在 CMakeLists.txt 中包含进去，例如:</p><p>include(/path/to/arm-linux.cmake)</p><h3 id="设置交叉编译器的根路径" tabindex="-1"><a class="header-anchor" href="#设置交叉编译器的根路径" aria-hidden="true">#</a> 设置交叉编译器的根路径</h3><p>在 CMakeLists.txt 文件中，使用 set 命令设置交叉编译器的根路径，例如：</p><div class="language-txt line-numbers-mode" data-ext="txt"><pre class="language-txt"><code>set(CMAKE_FIND_ROOT_PATH /path/to/toolchain/)
set(CMAKE_SYSROOT /path/to/sysroot/)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这里将交叉编译器根路径设置为 /path/to/toolchain/，系统根目录设置为 /path/to/sysroot/，这些路径应根据实际情况进行修改。</p><h3 id="传参数指定交叉编译工具链的-cmake文件" tabindex="-1"><a class="header-anchor" href="#传参数指定交叉编译工具链的-cmake文件" aria-hidden="true">#</a> 传参数指定交叉编译工具链的.cmake文件</h3><p>使用 -DCMAKE_TOOLCHAIN_FILE 选项指定交叉编译工具链的路径，例如：</p><p>cmake -DCMAKE_TOOLCHAIN_FILE=/path/to/arm-linux.cmake ..</p><p>这里将交叉编译工具链的路径设置为 /path/to/arm-linux.cmake，这样 CMake 就可以使用交叉编译工具链来生成针对嵌入式设备的代码。</p><h2 id="经验总结" tabindex="-1"><a class="header-anchor" href="#经验总结" aria-hidden="true">#</a> 经验总结</h2><h3 id="使用变量" tabindex="-1"><a class="header-anchor" href="#使用变量" aria-hidden="true">#</a> 使用变量</h3><p>使用变量可以使 CMakeLists.txt 文件更加简洁和易读，并且可以方便地修改编译选项和路径等常量。例如：</p><div class="language-txt line-numbers-mode" data-ext="txt"><pre class="language-txt"><code>set(CMAKE_CXX_FLAGS &quot;\${CMAKE_CXX_FLAGS} -std=c++11&quot;)
set(SOURCE_FILES main.cpp)
add_executable(my_exe \${SOURCE_FILES})
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>CMake 提供了许多内置变量来自定义构建过程，例如：</p><p>CMAKE_BUILD_TYPE：指定构建类型，可选值包括：</p><ul><li>Debug：用于在没有优化的情况下，使用带有调试符号构建库或可执行文件</li><li>Release：用于构建的优化的库或可执行文件，不包含调试符号</li><li>RelWithDebInfo：由于构建较少的优化库或可执行文件，包含调试符号</li><li>MinSizeRel：用于不增加目标代码大小的优化方式，来构建或可执行文件</li></ul><p>CMAKE_INSTALL_PREFIX：指定安装目录的路径。</p><p>CMAKE_CXX_COMPILER：指定 C++ 编译器的路径。</p><p>使用这些变量可以方便地定制构建过程，以满足特定的需求。</p><h3 id="使用-find-package" tabindex="-1"><a class="header-anchor" href="#使用-find-package" aria-hidden="true">#</a> 使用 find_package</h3><p>使用 find_package 命令可以方便地查找和配置依赖项，例如：</p><div class="language-txt line-numbers-mode" data-ext="txt"><pre class="language-txt"><code>find_package(OpenCV REQUIRED)
include_directories(\${OpenCV_INCLUDE_DIRS})
target_link_libraries(my_exe \${OpenCV_LIBS})
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样可以方便地使用 OpenCV 库，而不需要手动指定头文件和库文件路径。</p><h3 id="使用-add-subdirectory" tabindex="-1"><a class="header-anchor" href="#使用-add-subdirectory" aria-hidden="true">#</a> 使用 add_subdirectory</h3><p>实际项目中，通常会有多个模块，每个模块相当于一个子项目，使用 add_subdirectory 命令可以方便地构建子项目，例如：</p><p>add_subdirectory(my_lib)</p><p>target_link_libraries(my_exe my_lib)</p><p>这样可以方便地使用 my_lib 子项目，并将它链接到 my_exe 可执行文件中。</p><h3 id="使用-configure-file" tabindex="-1"><a class="header-anchor" href="#使用-configure-file" aria-hidden="true">#</a> 使用 configure_file</h3><p>使用 configure_file 命令可以方便地生成配置文件，例如：</p><div class="language-txt line-numbers-mode" data-ext="txt"><pre class="language-txt"><code>set (VERSION_MAJOR 1)
set (VERSION_MINOR 0)
set (SOFT_VERSION V\${VERSION_MAJOR}.\${VERSION_MINOR})

configure_file(config.h.in config.h)
include_directories(\${CMAKE_CURRENT_BINARY_DIR})
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样可以在生成过程中自动生成 config.h 文件，并将其包含在项目中。</p><p>config.h.in内容如下：</p><div class="language-C line-numbers-mode" data-ext="C"><pre class="language-C"><code>#ifndef CONFIG_H_IN
#define CONFIG_H_IN

/**
* 可配置版本号、日期等信息
*/

#define VERSION_MAJOR @VERSION_MAJOR@
#define VERSION_MINOR @VERSION_MINOR@
#define SOFT_VERSION @SOFT_VERSION@

#endif

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="自定义构建规则" tabindex="-1"><a class="header-anchor" href="#自定义构建规则" aria-hidden="true">#</a> 自定义构建规则</h3><p>使用 add_custom_command 和 add_custom_target 命令可以方便地添加自定义构建规则，例如：</p><div class="language-txt line-numbers-mode" data-ext="txt"><pre class="language-txt"><code>add_custom_command(
  OUTPUT my_output.txt
  COMMAND my_command arg1 arg2 &gt; my_output.txt
  DEPENDS my_input.txt
)

add_custom_target(my_target DEPENDS my_output.txt)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样可以在编译过程中执行自定义命令，并生成指定的输出文件。</p><h3 id="获取文件夹名称" tabindex="-1"><a class="header-anchor" href="#获取文件夹名称" aria-hidden="true">#</a> 获取文件夹名称</h3><p>get_filename_component(CURRENT_FOLDER \${CMAKE_CURRENT_SOURCE_DIR} NAME)</p>`,95),r=[t];function s(l,c){return a(),i("div",null,r)}const u=e(n,[["render",s],["__file","CMake教程.html.vue"]]);export{u as default};
