(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{417:function(t,s,e){"use strict";e.r(s);var n=e(2),i=Object(n.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"sqlite3性能优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#sqlite3性能优化"}},[t._v("#")]),t._v(" SQLite3性能优化")]),t._v(" "),s("h2",{attrs:{id:"场景描述"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#场景描述"}},[t._v("#")]),t._v(" 场景描述")]),t._v(" "),s("p",[t._v("有10000条数据需要插入数据库，原来未优化的代码为直接循环执行INSERT语句。")]),t._v(" "),s("div",{staticClass:"language-C++ extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('void test0()\n{\n    sqlite3 *db = NULL;\n    sqlite3_open("test0.db", &db);\n    auto begin = std::chrono::steady_clock::now();\n    sqlite3_exec(db, "CREATE TABLE Test(id INTEGER,msg TEXT);", 0, 0, 0);\n    const int m = 10000;\n    for (int i = 0; i < m; i++)\n    {\n        sqlite3_exec(db, "INSERT INTO Test(id,msg) VALUES(123,\'hello\');", 0, 0, 0);\n    }\n    auto end = std::chrono::steady_clock::now();\n    auto elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(end - begin).count();\n    printf("test0执行时间: %ld ms\\n", elapsed);\n    sqlite3_close(db);\n}\n')])])]),s("h2",{attrs:{id:"使用事务"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#使用事务"}},[t._v("#")]),t._v(" 使用事务")]),t._v(" "),s("p",[t._v("如果有许多数据需要插入数据库，逐条插入，导致频繁的提交以及磁盘 IO，使用事务机制，可以批量插入数据，可以极大的提升写入速度。")]),t._v(" "),s("div",{staticClass:"language-C++ extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('void test1()\n{\n    sqlite3* db = NULL;\n    sqlite3_open("test1.db", &db);\n    auto begin = std::chrono::steady_clock::now();\n    sqlite3_exec(db, "CREATE TABLE Test(id INTEGER,msg TEXT);", 0, 0, 0);\n    sqlite3_exec(db, "BEGIN;", 0, 0, 0);\n    const int m = 10000;\n    for (int i = 0; i < m; i++)\n    {\n        sqlite3_exec(db, "INSERT INTO Test(id,msg) VALUES(123,\'hello\');", 0, 0, 0);\n        if (i % 1000 == 999) {\n            sqlite3_exec(db, "COMMIT;", 0, 0, 0);\n            sqlite3_exec(db, "BEGIN;", 0, 0, 0);\n        }\n    }\n    sqlite3_exec(db, "COMMIT;", 0, 0, 0);\n\n    auto end = std::chrono::steady_clock::now();\n    auto elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(end - begin).count();\n\tprintf("test1执行时间: %ld ms\\n", elapsed);\n    sqlite3_close(db);\n}\n')])])]),s("h2",{attrs:{id:"使用执行准备"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#使用执行准备"}},[t._v("#")]),t._v(" 使用执行准备")]),t._v(" "),s("p",[t._v("执行准备相当于将 SQL 语句提前编译，省去每次执行 SQL 语句时候的语法检查等操作，可以极大优化 SQL 语句的执行效率。")]),t._v(" "),s("div",{staticClass:"language-C++ extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('void test2()\n{\n    sqlite3* db = NULL;\n    sqlite3_open("test2.db", &db);\n    sqlite3_exec(db, "CREATE TABLE Test(id INTEGER,msg TEXT);", 0, 0, 0);\n    sqlite3_stmt *stmt = NULL;\n    const char *sql = "INSERT INTO Test(id,msg) VALUES (?,?);";\n    auto begin = std::chrono::steady_clock::now();\n    sqlite3_prepare_v2(db, sql, strlen(sql), &stmt, 0);\n    sqlite3_exec(db, "BEGIN;", 0, 0, 0);\n    const int m = 10000;\n    for (int i = 0; i < m; i++) {\n        sqlite3_reset(stmt);\n        sqlite3_bind_int(stmt, 1, 123);\n        const char* str = "hello";\n        sqlite3_bind_text(stmt, 2, str, strlen(str), 0);\n        sqlite3_step(stmt);\n        if (i % 1000 == 999) {\n            sqlite3_exec(db, "COMMIT;", 0, 0, 0);\n            sqlite3_exec(db, "BEGIN;", 0, 0, 0);\n        }\n    }\n    sqlite3_exec(db, "COMMIT;", 0, 0, 0);\n    sqlite3_finalize(stmt);\n    auto end = std::chrono::steady_clock::now();\n    auto elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(end - begin).count();\n\tprintf("test2执行时间: %ld ms\\n", elapsed);\n    sqlite3_close(db);\n}\n')])])]),s("h2",{attrs:{id:"使用内存模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#使用内存模式"}},[t._v("#")]),t._v(" 使用内存模式")]),t._v(" "),s("p",[t._v('内存模式是将数据库直接创建到内存中，使用方法为 sqlite3_open 打开 ":memory:" ，内存模式相比普通模式，可以节省写文件时间。可以先将数据库创建到内存中，数据写入完整之后，再执行 VACUUM INTO语句将其写入到磁盘。使用内存模式写数据速度很快，但是一般用不到，毕竟我们一般用数据库就是为了数据的持久保存和读取。')]),t._v(" "),s("div",{staticClass:"language-C++ extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('void test3()\n{\n    sqlite3* db = NULL;\n    sqlite3_open(":memory:", &db);\n    sqlite3_exec(db, "CREATE TABLE Test(id INTEGER,msg TEXT);", 0, 0, 0);\n    sqlite3_stmt *stmt = NULL;\n    const char *sql = "INSERT INTO Test(id,msg) VALUES (?,?);";\n    auto begin = std::chrono::steady_clock::now();\n    sqlite3_prepare_v2(db, sql, strlen(sql), &stmt, 0);\n    sqlite3_exec(db, "BEGIN;", 0, 0, 0);\n    const int m = 10100;\n    for (int i = 0; i < m; i++) {\n        sqlite3_reset(stmt);\n        sqlite3_bind_int(stmt, 1, 123);\n        const char* str = "hello";\n        sqlite3_bind_text(stmt, 2, str, strlen(str), 0);\n        sqlite3_step(stmt);\n        if (i % 1000 == 999) {\n            sqlite3_exec(db, "COMMIT;", 0, 0, 0);\n            sqlite3_exec(db, "BEGIN;", 0, 0, 0);\n        }\n    }\n    sqlite3_exec(db, "COMMIT;", 0, 0, 0);\n    sqlite3_finalize(stmt);\n    sqlite3_exec(db, "VACUUM INTO \'test3.db\';", 0, 0, 0);\n    auto end = std::chrono::steady_clock::now();\n    auto elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(end - begin).count();\n\tprintf("test3执行时间: %ld ms\\n", elapsed);\n    sqlite3_close(db);\n}\n')])])]),s("h2",{attrs:{id:"修改写同步模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#修改写同步模式"}},[t._v("#")]),t._v(" 修改写同步模式")]),t._v(" "),s("p",[t._v("在 sqlite3 中 synchronous 有三种模式，分别是 FULL、NORMAL 和 OFF。默认synchronous值为FULL，在FULL模式下，保证数据不会损坏，安全性最高，但是写入速度也最慢。OFF 模式会比 FULL 模式快很多，但是数据损坏的可能性较大，不建议设为OFF。如果要加快写入速度，可以设置为NORMAL，速度比FULL快，并且几乎不会损坏数据（不是100%不会损坏）。\nsynchronous设置为NORMAL的方法为，在sqlite3_open语句后面加一行代码：")]),t._v(" "),s("div",{staticClass:"language-C++ extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('sqlite3_exec(db, "PRAGMA synchronous=NORMAL;", 0, 0, 0);\n')])])]),s("h2",{attrs:{id:"测试结果"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#测试结果"}},[t._v("#")]),t._v(" 测试结果")]),t._v(" "),s("p",[t._v("我在自己电脑上测试了以上各种情况，打印程序执行所用的时间(ms)，数据如下表：")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("synchronous")]),t._v(" "),s("th",[t._v("FULL(默认)")]),t._v(" "),s("th",[t._v("NORMAL")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("不优化")]),t._v(" "),s("td",[t._v("1447405")]),t._v(" "),s("td",[t._v("977747")])]),t._v(" "),s("tr",[s("td",[t._v("使用事务")]),t._v(" "),s("td",[t._v("1580")]),t._v(" "),s("td",[t._v("1168")])]),t._v(" "),s("tr",[s("td",[t._v("使用事务+执行准备")]),t._v(" "),s("td",[t._v("1436")]),t._v(" "),s("td",[t._v("1004")])]),t._v(" "),s("tr",[s("td",[t._v("使用事务+执行准备+内存模式")]),t._v(" "),s("td",[t._v("15")]),t._v(" "),s("td",[t._v("9")])])])])])}),[],!1,null,null,null);s.default=i.exports}}]);